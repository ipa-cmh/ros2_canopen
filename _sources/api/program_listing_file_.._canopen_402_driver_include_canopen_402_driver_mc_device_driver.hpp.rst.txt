
.. _program_listing_file_.._canopen_402_driver_include_canopen_402_driver_mc_device_driver.hpp:

Program Listing for File mc_device_driver.hpp
=============================================

|exhale_lsh| :ref:`Return to documentation for file <file_.._canopen_402_driver_include_canopen_402_driver_mc_device_driver.hpp>` (``../canopen_402_driver/include/canopen_402_driver/mc_device_driver.hpp``)

.. |exhale_lsh| unicode:: U+021B0 .. UPWARDS ARROW WITH TIP LEFTWARDS

.. code-block:: cpp

   #ifndef MC_DEVICE_DRIVER_HPP
   #define MC_DEVICE_DRIVER_HPP
   #include <iostream>
   #include <vector>
   #include <boost/container/flat_map.hpp>
   #include <boost/numeric/conversion/cast.hpp>
   #include <cstring>
   
   #include "canopen_402_driver/base.hpp"
   #include "canopen_base_driver/lely_bridge.hpp"
   
   using namespace ros2_canopen;
   namespace ros2_canopen
   {
       struct RemoteObject
       {
           uint16_t index;
           uint8_t subindex;
           uint32_t data;
           CODataTypes type;
           bool tpdo_mapped;
           bool rpdo_mapped;
           bool valid;
       };
   
       class MCDeviceDriver : public LelyBridge
       {
       private:
           std::vector<std::shared_ptr<RemoteObject>> objs;
           bool sync;
           double speed;
           double position;
   
       public:
           std::shared_ptr<RemoteObject> create_remote_obj(uint16_t index, uint8_t subindex, CODataTypes type)
           {
               RemoteObject obj = {index, subindex, 0, type, false, false, true};
               for(auto it = objs.begin(); it != objs.end(); ++it)
               {
                   if(
                       ((*it)->index == index)
                       &&
                       ((*it)->subindex == subindex)
                       &&
                       ((*it)->type == type)
                   )
                   {
                       return *it;
                   }
               }
               std::shared_ptr<RemoteObject> objp = std::make_shared<RemoteObject>(obj);
               objs.push_back(objp);
               return objp;
           }
   
           void OnRpdoWrite(uint16_t idx, uint8_t subidx) noexcept override
           {
               for (auto it = objs.begin(); it != objs.end(); ++it)
               {
                   std::shared_ptr<RemoteObject> obj = *it;
                   if (obj->index == idx && obj->subindex == subidx)
                   {
                       if(obj->type == CODataTypes::COData8)
                           obj->data = rpdo_mapped[idx][subidx].Read<uint8_t>();
                       else if(obj->type == CODataTypes::COData16)
                           obj->data = rpdo_mapped[idx][subidx].Read<uint16_t>();
                       else if(obj->type == CODataTypes::COData32)
                           obj->data = rpdo_mapped[idx][subidx].Read<uint32_t>();
                       break;
                   }
               }
   
               if(idx == 0x606C && subidx == 0x0)
               {
                   speed = rpdo_mapped[idx][subidx].Read<int32_t>();
               }
   
               if(idx == 0x6064 && subidx == 0x0)
               {
                   position = rpdo_mapped[idx][subidx].Read<int32_t>();
               }
           }
   
           template <typename T>
           void set_remote_obj(std::shared_ptr<RemoteObject> obj, T data)
           {
               T data_ = data;
               std::memcpy(&(obj->data), &data_, sizeof(T));
   
               COData d = {obj->index, obj->subindex, obj->data, obj->type};
               if (!obj->tpdo_mapped)
               {
   
                   auto f = this->async_sdo_write(d);
                   f.wait();
               }
               else
               {
                   this->tpdo_mapped[obj->index][obj->subindex] = data; 
                   this->tpdo_mapped[obj->index][obj->subindex].WriteEvent();
               }
           }
           template <typename T>
           T get_remote_obj(std::shared_ptr<RemoteObject> obj)
           {
               if (!obj->rpdo_mapped)
               {
                   COData d = {obj->index, obj->subindex, 0U, obj->type};
                   auto f = this->async_sdo_read(d);
                   f.wait();
                   try
                   {
                       obj->data = f.get().data_;
                   }
                   catch (std::exception &e)
                   {
                       obj->valid = false;
                   }
               }
               T data;
               std::memcpy(&data, &(obj->data), sizeof(T));
               return data;
           }
   
           template <typename T>
           T get_remote_obj_cached(std::shared_ptr<RemoteObject> obj)
           {
               T data;
               std::memcpy(&data, &(obj->data), sizeof(T));
               return data;
           }
   
           template <typename T>
           void set_remote_obj_cached(std::shared_ptr<RemoteObject> obj, const T data)
           {
               T data_ = data;
               std::memcpy(&(obj->data), &data_, sizeof(T));
           }
   
           void validate_objs()
           {
               for (auto it = objs.begin(); it != objs.end(); ++it)
               {
                   std::shared_ptr<RemoteObject> obj = *it;
   
                   try
                   {
                       switch (obj->type)
                       {
                       case CODataTypes::COData8:
                           obj->rpdo_mapped = this->tpdo_mapped[obj->index][obj->subindex].Read<uint8_t>();
                           break;
                       case CODataTypes::COData16:
                           obj->rpdo_mapped = this->tpdo_mapped[obj->index][obj->subindex].Read<uint16_t>();
                           break;
                       case CODataTypes::COData32:
                           obj->rpdo_mapped = this->tpdo_mapped[obj->index][obj->subindex].Read<uint32_t>();
                           break;
                       }
                       obj->tpdo_mapped = true;
                   }
                   catch (lely::canopen::SdoError &e)
                   {
                       obj->tpdo_mapped = false;
                   }
   
                   try
                   {
                       switch (obj->type)
                       {
                       case CODataTypes::COData8:
                           obj->rpdo_mapped = this->rpdo_mapped[obj->index][obj->subindex].Read<uint8_t>();
                           break;
                       case CODataTypes::COData16:
                           obj->rpdo_mapped = this->rpdo_mapped[obj->index][obj->subindex].Read<uint16_t>();
                           break;
                       case CODataTypes::COData32:
                           obj->rpdo_mapped = this->rpdo_mapped[obj->index][obj->subindex].Read<uint32_t>();
                           break;
                       }
                       obj->rpdo_mapped = true;
                   }
                   catch (lely::canopen::SdoError &e)
                   {
                       obj->rpdo_mapped = false;
                   }
   
                   switch (obj->type)
                   {
                   case CODataTypes::COData8:
                       obj->data = get_remote_obj<uint8_t>(obj);
                       break;
                   case CODataTypes::COData16:
                       obj->data = get_remote_obj<uint16_t>(obj);
                       break;
                   case CODataTypes::COData32:
                       obj->data = get_remote_obj<uint32_t>(obj);
                       break;
                   }
                   std::cout << "Initialised object :" 
                       << this->get_id() << " " 
                       << std::hex << obj->index << " " 
                       << std::dec << obj->subindex << " " 
                       << obj->data << " "
                       << "RPDO: " << (obj->rpdo_mapped ? "yes" : "no") << " "
                       << "TPDO: " << (obj->tpdo_mapped ? "yes" : "no") << " "
                       << std::endl;
               }
           }
   
           double get_speed()
           {
               return speed;
           }
   
           double get_position()
           {
               return position;
           }
   
           MCDeviceDriver(ev_exec_t *exec, canopen::AsyncMaster &master, uint8_t id)
               : LelyBridge(exec, master, id)
           {
               sync = true;
           }
       };
   
   }
   #endif
